const { query } = require('./rust-scriba.node');

class Statement {
    constructor(db, sql) {
        this.db = db;
        this.sql = sql;
    }

    async get(...params) {
        const res = await query(this.db.tenantId, this.sql, this.db.ttl);
        return Statement._processResult(res, 'get');
    }

    async all(...params) {
        const res = await query(this.db.tenantId, this.sql, this.db.ttl);
        return Statement._processResult(res, 'all');
    }

    async run(...params) {
        await query(this.db.tenantId, this.sql, this.db.ttl);
        return { changes: 1, lastInsertRowid: 0 };
    }

    static _processResult(resultString, type) {
        let data;
        try {
            data = JSON.parse(resultString);
        } catch (e) {
            throw new Error(`[Scriba] Invalid JSON from query: ${resultString}`);
        }

        if (type === 'get') {
            if (Array.isArray(data)) return data[0] ?? undefined;
            return data;
        } else if (type === 'all') {
            return Array.isArray(data) ? data : [data];
        }
    }
}

class Database {
    constructor(dbPath, options = {}) {
        this.tenantId = dbPath;
        this.ttl = options.ttl ?? 5000;
    }

    prepare(sql) {
        return new Statement(this, sql);
    }

    run(sql, ...params) {
        return this.prepare(sql).run(...params);
    }

    get(sql, ...params) {
        return this.prepare(sql).get(...params);
    }

    all(sql, ...params) {
        return this.prepare(sql).all(...params);
    }

    exec(sql) {
        return query(this.tenantId, sql, this.ttl).then(() => {});
    }

    transaction(fn) {
        return (...args) => fn(...args);
    }

    pragma() { /* stub */ }
    backup() { /* stub */ }
    serialize() { /* stub */ }
    function() { /* stub */ }
    aggregate() { /* stub */ }
    table() { /* stub */ }
    loadExtension() { /* stub */ }
    close() { /* stub */ }
}

module.exports = Database;
