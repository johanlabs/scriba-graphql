const { initCacheSystem, query } = require('./rust-scriba.node');
const redis = require('redis');

const { performance } = require('perf_hooks');

async function runBenchmark(options) {
  const ITERATIONS = options?.config?.iterations ?? 5000;
  const CONCURRENT = options?.config?.concurrent ?? 100;
  const LARGE_VALUE = 'x'.repeat(1024 * (options?.config?.largeValueInKb ?? 100));

  initCacheSystem();

  const redisClient = options?.url ? redis.createClient({ url: options.url }) : redis.createClient();
  await redisClient.connect();

  const key = 'test_key';
  const smallValue = JSON.stringify({ msg: 'hello world', ts: Date.now() });

  async function measure(fn) {
    const start = performance.now();
    await fn();
    return performance.now() - start;
  }

  async function latencyPercentiles(getFn) {
    const latencies = [];
    for (let i = 0; i < ITERATIONS; i++) {
      const start = performance.now();
      await getFn();
      latencies.push(performance.now() - start);
    }
    latencies.sort((a, b) => a - b);
    return {
      p50: latencies[Math.floor(ITERATIONS * 0.5)],
      p95: latencies[Math.floor(ITERATIONS * 0.95)],
      p99: latencies[Math.floor(ITERATIONS * 0.99)],
    };
  }

  async function mixedOperations(getFn, setFn) {
    return await measure(async () => {
      const tasks = [];
      for (let i = 0; i < ITERATIONS; i++) {
        if (Math.random() < 0.7) tasks.push(getFn());
        else tasks.push(setFn());
      }
      await Promise.all(tasks);
    });
  }

  const results = {};

  results.latency = {
    redisSet: await measure(async () => {
      for (let i = 0; i < ITERATIONS; i++) await redisClient.set(key, smallValue);
    }),
    redisGet: await measure(async () => {
      for (let i = 0; i < ITERATIONS; i++) await redisClient.get(key);
    }),
    rustSet: await measure(async () => {
      for (let i = 0; i < ITERATIONS; i++)
        await query('_benchmark', `SET ${key} ${smallValue}`, 10000);
    }),
    rustGet: await measure(async () => {
      for (let i = 0; i < ITERATIONS; i++)
        await query('_benchmark', `GET ${key}`, 10000);
    })
  };

  results.concurrent = {
    redisSet: await measure(async () => {
      const tasks = Array.from({ length: CONCURRENT }, () =>
        redisClient.set(key, smallValue)
      );
      await Promise.all(tasks);
    }),
    redisGet: await measure(async () => {
      const tasks = Array.from({ length: CONCURRENT }, () =>
        redisClient.get(key)
      );
      await Promise.all(tasks);
    }),
    rustSet: await measure(async () => {
      const tasks = Array.from({ length: CONCURRENT }, () =>
        query('_benchmark', `SET ${key} ${smallValue}`, 10000)
      );
      await Promise.all(tasks);
    }),
    rustGet: await measure(async () => {
      const tasks = Array.from({ length: CONCURRENT }, () =>
        query('_benchmark', `GET ${key}`, 10000)
      );
      await Promise.all(tasks);
    })
  };

  results.percentiles = {
    redis: await latencyPercentiles(() => redisClient.get(key)),
    rust: await latencyPercentiles(() => query('_benchmark', `GET ${key}`, 10000)),
  };

  results.mix = {
    redis: await mixedOperations(
      () => redisClient.get(key),
      () => redisClient.set(key, smallValue)
    ),
    rust: await mixedOperations(
      () => query('_benchmark', `GET ${key}`, 10000),
      () => query('_benchmark', `SET ${key} ${smallValue}`, 10000)
    )
  };

  results.largeValues = {
    redisSet: await measure(async () => {
      for (let i = 0; i < 500; i++) await redisClient.set(key, LARGE_VALUE);
    }),
    redisGet: await measure(async () => {
      for (let i = 0; i < 500; i++) await redisClient.get(key);
    }),
    rustSet: await measure(async () => {
      for (let i = 0; i < 500; i++)
        await query('_benchmark', `SET ${key} ${LARGE_VALUE}`, 10000);
    }),
    rustGet: await measure(async () => {
      for (let i = 0; i < 500; i++)
        await query('_benchmark', `GET ${key}`, 10000);
    })
  };

  await redisClient.quit();
  return results;
}

module.exports = { runBenchmark };
