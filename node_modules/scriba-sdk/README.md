# ðŸ“ **Scriba â€” The Zero-Learning Curve Reactive ORM**

Scriba is a minimalist, reactive, SQLite-powered ORM designed with one radical principle:

> **â€œIf it feels like working with plain JavaScript objects, you're doing it right.â€**

Forget complex schemas, migrations, data mappers, or cryptic APIs. Scriba turns every database row into a **live object**: accessing a property loads it lazily, updating it writes to the database instantly, and relations behave like native properties.

Scriba is not just an ORM â€” it is the **easiest and most intuitive persistence layer you can use in JavaScript.**

---

## ðŸš€ Features

* **Zero Learning Curve**
  You work with normal JS objects. No `.save()`, `.update()`, `.populate()`, `.from()`, or `.select()`.

* **Auto-Persisting Objects**
  Assigning a property automatically updates SQLite:

  ```js
  user.name = "Alice"; // Writes instantly to DB
  ```

* **Lazy Loading**
  Accessing a field loads it on demand:

  ```js
  user = User[3]; // Auto SELECT * WHERE id = 3
  ```

* **Reactive Records**
  Subscribe to live updates:

  ```js
  user.subscribe(u => console.log("Updated:", u));
  ```

* **1:N and N:N Relations Automatically Resolved**
  If your schema defines relations, you get:

  ```js
  user.posts;  // Auto SELECT posts
  user.roles;  // Auto SELECT through join table
  ```

* **Type-Aware Fields**
  JSON â†’ JS object
  datetime â†’ Date instance
  boolean â†’ native boolean

* **Hot Schema Reload (with auto-migrations)**
  Update your `.scriba` schema file and watch your tables update automatically.

* **Multi-Tenant by Design**
  Each tenant gets its own isolated SQLite database and schema.

---

## ðŸ“¦ Installation

```bash
npm install scriba
```

*(or whatever your real package name will be)*

---

## ðŸ§  How It Works

Scriba uses four core abstractions:

### `Scriba`

Multi-tenant manager, schema loader, table initializer.

### `TenantProxy`

Gives easy access to entities inside a tenant.

### `TableProxy`

Represents a database table.
Responsible for:

* lazy loading
* record caching
* inserts
* queries
* relation metadata

### `RecordProxy`

Represents a single record.
Through a JavaScript `Proxy`, it intercepts:

* `get` â†’ loads relations, parses types, returns cached values
* `set` â†’ normalizes, auto-updates SQLite, notifies subscribers, invalidates caches

---

## ðŸ§© Basic Usage

### 1. Initialize Scriba

```js
import Scriba from "scriba";

const scriba = new Scriba([
  { id: "app", path: "./app.db", schema: "./schema.scriba" }
]);
```

---

### 2. Define a Schema (`schema.scriba`)

```
model User {
  id int
  name text
  age int
}

model Post {
  id int
  userId int
  title text
  content text
}
```

Scriba automatically:

* creates tables if they donâ€™t exist
* adds missing columns
* reloads when the file changes

---

### 3. Insert Data

```js
const tenant = scriba.tenant("app");
const User = tenant.entity("User");

const alice = await User.push({
  name: "Alice",
  age: 25
});
```

---

### 4. Fetch Data (lazy)

```js
const u = User[1]; // Auto SELECT

console.log(u.name);
```

---

### 5. Auto-Saving

```js
u.age = 26; 
// Immediately: UPDATE User SET age = 26 WHERE id = 1
```

---

### 6. Relations (zero configuration)

If the schema contains something like `userId`, Scriba exposes:

```js
u.posts;  
// SELECT * FROM Post WHERE userId = u.id
```

---

### 7. Reactive Subscriptions

```js
u.subscribe(user => {
  console.log("User updated:", user);
});
```

Now any assignment triggers the subscriber.

---

## ðŸ”¥ Example: Many-to-Many

Assume the schema:

```
model User {
  id int
  name text
}

model Role {
  id int
  label text
}

model UserRole {
  userId int
  roleId int
}
```

Scriba detects `User â†” Role` via `UserRole`.

Then you get:

```js
user.roles; // Auto SELECT through join table
```

---

## ðŸ“Š Querying

Simple, expressive:

```js
User.query(
  { age: { $gt: 18 } },
  { sort: "age DESC", limit: 10 }
);
```

Returns real `RecordProxy` instances.

---

## â¤ï¸ Why Scriba?

While traditional ORMs (Prisma, Sequelize, Drizzle) require learning large APIs or DSLs, Scriba has one goal:

> **Make database persistence feel like normal JavaScript.**

* No `.save()`
* No `.update()`
* No `.populate()`
* No decorators, models, or classes
* No migrations to write manually

Just:

```js
const tenant = scribe.tentant("database");
const user = tenant.entity("User");

user[1].name = "New Name";

console.log(user.posts);

```

If you know JavaScript, you already know Scriba.

---

## ðŸ“„ License

MIT
Use freely, modify freely.