// TableProxy.js
import RecordProxy from "./RecordProxy.js";
import { randomUUID } from "crypto";

function mapPrismaToSQLite(type) {
	switch (type) {
		case "Int": return "INTEGER";
		case "Float": return "REAL";
		case "Boolean": return "INTEGER";
		case "DateTime": return "TEXT";
		case "Json": return "TEXT";
		case "String":
		default: return "TEXT";
	}
}

class TableProxy {
	constructor(db, modelName, fields, scriba, tenantId) {
		this._db = db;
		this._modelName = modelName;
		this._fields = fields;
		this._records = {};
		this._relations = {};
		this._nnRelations = {};
		this._scriba = scriba;
		this._tenantId = tenantId;
		this._stmtCache = {};
		this._hooks = {
			beforeCreate: [],
			afterCreate: [],
			beforeUpdate: [],
			afterUpdate: [],
			beforeDelete: [],
			afterDelete: []
		};

		return new Proxy(this, {
			get: (t, p) => {
				if (typeof p === "symbol") return t[p];
				if (p in t) return t[p];

				const key = String(p);
				if (t._records[key]) return t._records[key];

				let sql = `SELECT * FROM ${t._modelName} WHERE id = ?`;
				if (t._hasSoftDelete()) sql += ` AND deletedAt IS NULL`;
				const row = t._db.prepare(sql).get(key);
				if (row) {
					const rec = new RecordProxy(t, row);
					t._records[row.id] = rec;
					return rec;
				}
				return undefined;
			},
			deleteProperty: (t, p) => {
				return t.delete(p);
			}
		});
	}

	addHook(type, callback) {
		if (!this._hooks[type]) throw new Error(`Tipo de hook invÃ¡lido: ${type}`);
		this._hooks[type].push(callback);
	}

	_hasSoftDelete() {
		return this._fields.some(f => f.name === "deletedAt");
	}

	_normalizeValue(fieldName, value) {
		const field = this._fields.find(f => f.name === fieldName);
		if (!field) return value;
		if (value == null) return null;
		if (field.type === "DateTime" && value === "") return "";
		switch (field.type) {
			case "Int": return Number.isFinite(Number(value)) ? Number(value) : null;
			case "Float": return parseFloat(value);
			case "Boolean": return value ? 1 : 0;
			case "DateTime": 
				const date = new Date(value);
				if (isNaN(date.getTime())) throw new Error(`Invalid Date value for ${fieldName}: ${value}`);
				return date.toISOString();
			case "Json": return JSON.stringify(value);
			case "String":
			default:
				return String(value);
		}
	}

	_applyRules(recordOrData, isUpdate = false) {
		const tenant = this._scriba.tenant(this._tenantId);
		const table = tenant.entity(this._modelName);
		if (table.rules && Array.isArray(table.rules)) {
			for (const rule of table.rules) {
				const res = rule(recordOrData, isUpdate, recordOrData.id);
				if (res === false) throw new Error(`Validation rule failed on ${this._modelName}`);
			}
		}
	}

	async _updateDB(record, updates) {
		this._applyRules(record, true);

		let data = { ...updates };
		for (const hook of this._hooks.beforeUpdate) {
			try {
				const res = await hook(record, data);
				if (res && typeof res === 'object') data = res;
				if (res === false) return false;
			} catch (e) { console.error(`beforeUpdate Hook falhou: ${e.message}`); return false; }
		}

		const finalUpdates = data;
		const finalUpdateKeys = Object.keys(finalUpdates).filter(k => k !== "id");
		if (finalUpdateKeys.length === 0) return true;

		const setClauses = finalUpdateKeys.map(k => `${k} = ?`).join(", ");
		const values = finalUpdateKeys.map(k => finalUpdates[k]);
		values.push(record.id);

		const info = this._db.prepare(`UPDATE ${this._modelName} SET ${setClauses} WHERE id = ?`).run(...values);

		if (info.changes > 0) {
			for (const hook of this._hooks.afterUpdate) {
				try { await hook(record, finalUpdates); } catch (e) { console.error(`afterUpdate Hook falhou: ${e.message}`); }
			}
		}
		return info.changes > 0;
	}

	all(includeDeleted = false) {
		let sql = `SELECT * FROM ${this._modelName}`;
		if (this._hasSoftDelete() && !includeDeleted) sql += ` WHERE deletedAt IS NULL`;
		const rows = this._db.prepare(sql).all();
		return rows.map(r => { if (!this._records[r.id]) this._records[r.id] = new RecordProxy(this, r); return this._records[r.id]; });
	}

	delete(id) {
		const idStr = String(id);
		for (const hook of this._hooks.beforeDelete) {
			try { if (hook(idStr) === false) return false; } catch (e) { console.error(`beforeDelete Hook falhou: ${e.message}`); return false; }
		}

		let info;
		if (this._hasSoftDelete()) {
			const now = new Date().toISOString();
			info = this._db.prepare(`UPDATE ${this._modelName} SET deletedAt = ? WHERE id = ?`).run(now, idStr);
			delete this._records[idStr];
		} else {
			info = this._db.prepare(`DELETE FROM ${this._modelName} WHERE id = ?`).run(idStr);
			delete this._records[idStr];
		}

		const success = info.changes > 0;
		if (success) {
			for (const hook of this._hooks.afterDelete) {
				try { hook(idStr); } catch (e) { console.error(`afterDelete Hook falhou: ${e.message}`); }
			}
		}
		return success;
	}

	async push(data = {}) {
		this._applyRules(data, false);

		const idField = this._fields.find(f => f.isId);
		const validated = {};
		const nowISO = new Date().toISOString();
		for (const field of this._fields) {
			let v = data[field.name];
			const isAuditField = field.name === "createdAt" || field.name === "updatedAt";
			if (isAuditField) v = v ?? nowISO;
			else if (v === undefined || v === null) {
				if (!field.isId && !field.isOptional && field.name !== 'deletedAt') {
					v = field.type === "Int" || field.type === "Float" || field.type === "Boolean" ? 0 : "";
				} else v = null;
			}
			if (field.isId && (v === null || v === undefined)) v = field.type === "String" ? randomUUID() : null;
			validated[field.name] = this._normalizeValue(field.name, v);
		}

		const keys = Object.keys(validated);
		const vals = keys.map(k => validated[k]);
		const fieldsStr = keys.join(",");
		const placeholders = keys.map(() => "?").join(",");

		console.log(`INSERT INTO ${this._modelName} (${fieldsStr}) VALUES (${placeholders})`)
		const stmt = this._db.prepare(`INSERT INTO ${this._modelName} (${fieldsStr}) VALUES (${placeholders})`);
		const info = stmt.run(...vals);

		let newId = validated.id ?? (idField?.type === "Int" ? info.lastInsertRowid : validated.id);
		validated.id = newId;
		const rec = new RecordProxy(this, validated);
		this._records[String(newId)] = rec;

		for (const hook of this._hooks.afterCreate) {
			try { await hook(rec); } catch (e) { console.error(`afterCreate Hook falhou: ${e.message}`); }
		}

		return rec;
	}

	find(predicate) { return Object.values(this._records).find(predicate); }
	filter(predicate) { return Object.values(this._records).filter(predicate); }
	query(conditions = {}, options = {}) {
		let sql = `SELECT * FROM ${this._modelName}`;
		const keys = Object.keys(conditions);
		const params = [];
		const whereClauses = [];
		if (this._hasSoftDelete() && !options.includeDeleted) whereClauses.push("deletedAt IS NULL");
		keys.forEach(k => {
			const val = conditions[k];
			if (typeof val === "object" && val !== null) {
				if ("$gt" in val) { params.push(val['$gt']); whereClauses.push(`${k} > ?`); }
				else if ("$lt" in val) { params.push(val['$lt']); whereClauses.push(`${k} < ?`); }
			} else { params.push(val); whereClauses.push(`${k} = ?`); }
		});
		if (whereClauses.length) sql += ` WHERE ${whereClauses.join(' AND ')}`;
		if (options.sort) sql += ` ORDER BY ${options.sort}`;
		if (options.limit) sql += ` LIMIT ${options.limit}`;
		const rows = this._db.prepare(sql).all(...params);
		return rows.map(r => { if (!this._records[r.id]) this._records[r.id] = new RecordProxy(this, r); return this._records[r.id]; });
	}
}

export default TableProxy;