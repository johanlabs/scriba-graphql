// Scriba.js
import Database from "better-sqlite3";
import pluralize from "pluralize";
import chokidar from "chokidar";

import TableProxy from "./TableProxy.js";
import { loadPrismaModels } from "./parser/Prisma.js";
import RecordProxy from "./RecordProxy.js";

const { singular } = pluralize;

class TenantProxy {
  constructor(scriba, tenantId) {
    this._scriba = scriba;
    this._tenantId = tenantId;
  }
  entity(name) {
    return this._scriba.entity(name, this._tenantId);
  }
}

function mapPrismaToSQLite(type, enums) {
  if (enums && enums[type]) return "TEXT";
  switch (type) {
    case "Int": return "INTEGER";
    case "Float": return "REAL";
    case "Boolean": return "INTEGER";
    case "DateTime": return "TEXT";
    case "Json": return "TEXT";
    case "String":
    default: return "TEXT";
  }
}

class Scriba {
  constructor(tenantPaths = []) {
    this._tenants = {};
    tenantPaths.forEach(({ id, path, schema }) => {
      this.addTenant({ id, path, schema });
    });

    // Injeta globals automágicos
    this._injectGlobals();
  }

  // === Adicionar tenant em runtime ===
  addTenant({ id, path, schema }) {
    if (this._tenants[id]) throw new Error(`Tenant ${id} já existe`);

    const db = new Database(path);
    this._tenants[id] = { db, tables: {}, schemaPath: schema };

    if (schema) {
      this.loadSchema(id, schema);
      this._watchSchema(id, schema);
    }

    console.log(`[${id}] Tenant adicionado com sucesso!`);
  }

  tenant(id) {
    if (!this._tenants[id]) throw new Error(`Tenant ${id} não encontrado`);
    return new TenantProxy(this, id);
  }

  _watchSchema(tenantId, schemaPath) {
    const watcher = chokidar.watch(schemaPath, { ignoreInitial: true });
    watcher.on("change", () => {
      console.log(`[${tenantId}] Schema alterado! Reloading...`);
      this.loadSchema(tenantId, schemaPath);
    });
  }

  loadSchema(tenantId, schemaPath) {
    const t = this._tenants[tenantId];
    if (!t) throw new Error(`Tenant ${tenantId} não encontrado`);

    const { models, enums } = loadPrismaModels(schemaPath);

    for (const [modelName, def] of Object.entries(models)) {
      const hasId = def.fields.some(f => f.isId || f.name === "id");
      if (!hasId) {
        def.fields.unshift({
          name: "id",
          type: "String",
          isList: false,
          isOptional: false,
          isId: true,
          default: "uuid()",
          rawAttributes: [],
          relation: null
        });
      } else {
        for (const f of def.fields) {
          if (f.name === "id" && !f.isId) f.isId = true;
        }
      }

      // Auditoria
      const defaultAuditFields = [
        { name: 'createdAt', type: 'DateTime', isList: false, isOptional: false, isRequired: true, rawAttributes: [] },
        { name: 'updatedAt', type: 'DateTime', isList: false, isOptional: false, isRequired: true, rawAttributes: [] },
        { name: 'deletedAt', type: 'DateTime', isList: false, isOptional: true, isNullable: true, rawAttributes: [] },
      ];
      for (const dField of defaultAuditFields) {
        const exists = def.fields.some(f => f.name === dField.name);
        if (!exists) def.fields.push(dField);
      }
    }

    // Cria tabelas SQLite
    for (const [modelName, def] of Object.entries(models)) {
      const fields = def.fields;
      const columnsSQL = fields.map(f => {
        const colType = mapPrismaToSQLite(f.type, enums);
        let colDef = `\"${f.name}\" ${colType}`;
        if (f.isId && f.type === "Int") colDef += " PRIMARY KEY";
        else if (f.isId && f.type === "String") colDef += " UNIQUE";

        if (enums && enums[f.type]) {
          const allowed = enums[f.type].map(v => `'${v.replace("'", "''")}'`).join(",");
          colDef += ` CHECK (${f.name} IN (${allowed}))`;
        }
        if (!f.isOptional && f.name !== 'deletedAt') colDef += " NOT NULL";
        return colDef;
      }).join(", ");

      t.db.prepare(`CREATE TABLE IF NOT EXISTS \"${modelName}\" (${columnsSQL})`).run();

      // Adiciona colunas faltantes
      const existing = t.db.prepare(`PRAGMA table_info(\"${modelName}\")`).all().map(c => c.name);
      for (const f of fields) {
        if (!existing.includes(f.name)) {
          const colType = mapPrismaToSQLite(f.type, enums);
          let colDef = `\"${f.name}\" ${colType}`;
          if (!f.isOptional && f.name !== 'deletedAt') colDef += " NOT NULL DEFAULT ''";
          t.db.prepare(`ALTER TABLE \"${modelName}\" ADD COLUMN ${colDef}`).run();
        }
      }

      // Cria TableProxy
      t.tables[modelName.toLowerCase()] = new TableProxy(t.db, modelName, def.fields, this, tenantId);
    }

    // Detecta relações
    for (const [modelName, def] of Object.entries(models)) {
      const table = t.tables[modelName.toLowerCase()];
      for (const f of def.fields) {
        if (f.name.endsWith("Id") && f.name !== "id") {
          const parentTableName = f.name.slice(0, -2).toLowerCase();
          const parentTable = t.tables[parentTableName] || t.tables[parentTableName + "s"];
          if (parentTable) {
            parentTable._relations = parentTable._relations || {};
            const relName = singular(table._modelName.toLowerCase());
            parentTable._relations[relName] = { table: table._modelName.toLowerCase(), field: f.name };
            table._parentField = f.name;
          }
        }
      }
    }

    console.log(`[${tenantId}] Schema loaded: models=${Object.keys(models).join(", ")}, enums=${Object.keys(enums).join(", ")}`);
  }

  entity(name, tenantId) {
    const tenant = this._tenants[tenantId];
    if (!tenant) throw new Error(`Tenant ${tenantId} não encontrado`);
    return tenant.tables[name.toLowerCase()];
  }

  tenants() {
    return Object.keys(this._tenants);
  }

  // =========================================
  // INJEÇÃO GLOBAL AUTOMÁTICA, COMPATÍVEL
  _injectGlobals() {
    for (const tenantId of Object.keys(this._tenants)) {
      if (globalThis[tenantId]) continue; // não sobrescreve se já existe

      const tenantProxy = new Proxy({}, {
        get: (target, entityName) => {
          if (!entityName) return undefined;
          const table = this.entity(entityName, tenantId);
          if (!table) return undefined;

          // Proxy da entidade
          return new Proxy(table, {
            get(entTarget, prop) {
              if (prop === "query") return entTarget.query.bind(entTarget);
              if (prop === "push") return entTarget.push.bind(entTarget);

              // Se prop for numérico -> retorna RecordProxy
              if (!isNaN(prop)) {
                const row = entTarget.query({ id: prop }).pop() || {};
                return new RecordProxy(entTarget, row);
              }

              return entTarget[prop];
            }
          });
        }
      });

      globalThis[tenantId] = tenantProxy;
    }
  }
}

export default Scriba;
