export type Condition = {
  type?: string;
  field?: string;
  value?: any;
  valueFrom?: string;
  expression?: string;
  and?: Condition[];
  or?: Condition[];
  not?: Condition;
};

export type ActionPayload = Record<string, any>;

export type ActionFn = (params: { record: any; payload: ActionPayload }) => Promise<void> | void;

export type Rule = {
  conditions: Condition | Condition[];
  actions: Array<{ type: string } & ActionPayload>;
  priority?: number;
};

export class RuleEngine {
  private conditions: Record<string, (record: any, cond: Condition) => boolean>;
  private actions: Record<string, ActionFn>;

  constructor({
    conditions = {},
    actions = {},
  }: {
    conditions?: Record<string, (record: any, cond: Condition) => boolean>;
    actions?: Record<string, ActionFn>;
  } = {}) {
    this.conditions = { ...conditions };
    this.actions = { ...actions };
  }

  registerCondition(name: string, fn: (record: any, cond: Condition) => boolean) {
    this.conditions[name] = fn;
  }

  registerAction(name: string, fn: ActionFn) {
    this.actions[name] = fn;
  }

  private resolveExpression(record: any, expr: string) {
    if (!expr) return undefined;
    const replaced = expr.replace(/{{(.*?)}}/g, (_, field) => {
      const value = field.split('.').reduce((obj: { [x: string]: any; }, key: string | number) => obj?.[key], record);
      return JSON.stringify(value);
    });
    return Function('"use strict"; return (' + replaced + ')')();
  }

  evaluateCondition(cond: Condition, record: any): boolean {
    if (!cond) return true;

    if (cond.and) return cond.and.every(c => this.evaluateCondition(c, record));
    if (cond.or) return cond.or.some(c => this.evaluateCondition(c, record));
    if (cond.not) return !this.evaluateCondition(cond.not, record);

    if (cond.expression) {
      return Boolean(this.resolveExpression(record, cond.expression));
    }

    if (cond.type && this.conditions[cond.type]) {
      return this.conditions[cond.type](record, cond);
    }

    return true;
  }

  async executeActions(record: any, actions: Array<{ type: string } & ActionPayload>): Promise<void> {
    const actionList = Array.isArray(actions) ? actions : [actions];
    for (const act of actionList) {
      const fn = this.actions[act.type];
      if (!fn) throw new Error(`Action type "${act.type}" not registered`);
      await fn({ record, payload: act });
    }
  }

  async applyRule(record: any, rule: Rule): Promise<void> {
    const conditions = Array.isArray(rule.conditions) ? rule.conditions : [rule.conditions];
    const allTrue = conditions.every(cond => this.evaluateCondition(cond, record));
    if (!allTrue) return;

    await this.executeActions(record, rule.actions);
  }

  async applyRules(record: any, rules: Rule[]): Promise<void> {
    const sortedRules = [...rules].sort((a, b) => (b.priority || 0) - (a.priority || 0));
    for (const rule of sortedRules) {
      await this.applyRule(record, rule);
    }
  }
}
