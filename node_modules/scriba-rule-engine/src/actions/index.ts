import { ActionFn } from "../engine/RuleEngine";

function resolveExpression(record: any, expr: string) {
    const replaced = expr.replace(/{{(.*?)}}/g, (_, field) => {
        const value = field.split('.').reduce((obj: { [x: string]: any; }, key: string | number) => obj?.[key], record);
        return JSON.stringify(value);
    });
    return Function('"use strict"; return (' + replaced + ')')();
}

export const defaultActions: Record<string, ActionFn> = {
    throw: async ({ payload, record }) => {
        let msg = payload.message;
        if (msg?.includes('{{')) msg = resolveExpression(record, msg);
        throw new Error(msg || 'Rule violated');
    },

    log: async ({ payload, record }) => {
        let msg = payload.message;
        if (msg?.includes('{{')) msg = resolveExpression(record, msg);
        console.log(msg || 'Log:', payload);
    },

    setField: async ({ record, payload }) => {
        let value;
        if ('value' in payload) value = payload.value;
        else if (payload.expression) value = resolveExpression(record, payload.expression);
        else if (payload.valueFrom) {
            const expr = typeof payload.valueFrom === 'string' && payload.valueFrom.includes('{{')
                ? payload.valueFrom
                : `{{${payload.valueFrom}}}`;
            value = resolveExpression(record, expr);
        }

        const parts = payload.field.split('.');
        let target = record;
        for (let i = 0; i < parts.length - 1; i++) {
            target[parts[i]] = target[parts[i]] || {};
            target = target[parts[i]];
        }
        target[parts[parts.length - 1]] = value;
    },

    callFunction: async ({ record, payload }) => {
        if (typeof payload.fn !== 'function') throw new Error('Payload must include a function under "fn"');
        const args = payload.args?.map((a: string | string[]) => (typeof a === 'string' && a.includes('{{')) ? resolveExpression(record, a) : a) || [];
        await payload.fn(record, ...args);
    },

    callWebhook: async ({ record, payload }) => {
        const body = JSON.parse(JSON.stringify(payload.payload || {}, (key, value) => {
            if (typeof value === 'string' && value.includes('{{')) return resolveExpression(record, value);
            return value;
        }));
        await fetch(payload.url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
    },
};
